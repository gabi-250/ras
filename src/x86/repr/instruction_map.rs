# ! [doc = r" This file was autogenerated by build.rs."]use crate::x86::repr::{InstructionRepr, OperandKind, OperandRepr};
use crate::x86::Mnemonic;
use std::collections::hash_map::Entry;
use std::collections::HashMap;
lazy_static::lazy_static! { pub (crate) static ref INSTR_REPRS : HashMap < Mnemonic , Vec < InstructionRepr >> = { let mut instrs : HashMap < Mnemonic , Vec < InstructionRepr >> = HashMap :: new () ; let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (55u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (10u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (213u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (10u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (212u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (63u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (20u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (21u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (21u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (21u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (16u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (16u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (17u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (17u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (17u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (18u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (18u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (19u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (19u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (19u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (4u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (5u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (5u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (5u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (2u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (2u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (36u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (37u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (37u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (37u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (32u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (32u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (33u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (33u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (33u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (34u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (34u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (35u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (35u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (35u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (99u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ARPL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (98u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BOUND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (98u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BOUND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (188u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (188u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (188u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (189u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (189u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (189u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BSWAP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BSWAP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (187u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (187u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (187u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (179u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (179u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (179u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (186u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (232u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (154u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (152u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CBW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (152u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CWDE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (152u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CDQE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (248u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (252u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLFLUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLFLUSHOPT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (250u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (6u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CLTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (245u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (68u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (68u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (68u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (70u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (66u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (71u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (67u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (78u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (76u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (77u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (79u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (65u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (65u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (65u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (75u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (75u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (75u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (73u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (73u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (73u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (69u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (64u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (64u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (64u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (74u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (60u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (61u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (61u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (61u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (56u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (56u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (57u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (57u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (57u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (58u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (58u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (59u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (59u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (59u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (166u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (166u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (167u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMPSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG8B) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CMPXCHG16B) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (162u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CPUID) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (45u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTPD2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (42u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTPI2PD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (42u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTPI2PS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (45u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTPS2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (44u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTTPD2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (44u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CVTTPS2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (153u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CWD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (153u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: CDQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (153u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: CQO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (39u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DAA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (47u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (254u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (254u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (119u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: EMMS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (200u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: F2XM1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (225u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FABS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADDP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FADDP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FBLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FBSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (224u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCHS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (226u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCLEX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (226u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNCLEX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVU) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCMOVNU) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMPP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOMIP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOMI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOMIP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FCOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDECSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (249u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FDIVRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FFREE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FICOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FICOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FICOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FICOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FINCSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (227u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FINIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (227u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNINIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (223u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (232u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLD1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (233u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDL2T) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (234u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDL2E) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (235u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDPI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (236u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDLG2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (237u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDLN2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (238u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FLDENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMULP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FMULP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FIMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (243u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FPATAN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (248u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FPREM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (245u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FPREM1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (242u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FPTAN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (252u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FRNDINT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (253u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSCALE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (254u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSIN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (251u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSINCOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (250u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSQRT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (219u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNSTCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNSTENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (224u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (224u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FNSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (233u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (216u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (220u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (225u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FSUBRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (218u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (222u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FISUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (228u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FTST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (225u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (221u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (233u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (233u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FUCOMPP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (229u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (217u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXCH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXCH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: FXRSTOR64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: FXSAVE64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (244u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FXTRACT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FYL2X) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (249u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FYL2XP1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (244u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: HLT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (107u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (107u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (107u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (105u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (105u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (105u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (228u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (229u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (229u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (236u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (237u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (237u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (254u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (254u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (64u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (64u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (108u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (109u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (109u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (108u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (109u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (109u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (204u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (206u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INTO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (8u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INVD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (15u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: INVLPG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (207u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (207u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: IRETD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (207u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: IRETQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JCXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JECXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JRCXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (130u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (130u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (132u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (132u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (143u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (141u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (140u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (142u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (130u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (133u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (142u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (140u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (141u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (143u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (139u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (137u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (133u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (138u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (138u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (139u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (136u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (233u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (205u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (234u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (159u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LAHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (2u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (2u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (197u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LDS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (197u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LDS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (178u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (178u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (178u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (196u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (196u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (180u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (180u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (180u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (181u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (181u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (181u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (141u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (141u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (141u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (232u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LOCK) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (172u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (172u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LODSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: LODSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LOOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LOOPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LOOPNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (3u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: LTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MASKMOVQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (200u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MONITOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (136u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (136u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (137u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (137u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (137u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (138u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (138u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (139u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (139u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (139u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (140u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (140u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (142u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (142u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (160u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (160u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (162u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (162u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (163u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (176u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (176u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (198u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (198u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (32u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (32u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (32u8 , false , Some ("REX.R") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (34u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (34u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (34u8 , false , Some ("REX.R") , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (33u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (33u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (35u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (35u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (240u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (241u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (214u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVDQ2Q) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (195u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVNTI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (195u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVNTI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (231u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVNTQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (214u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVQ2DQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (164u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (164u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (190u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (190u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (190u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (191u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (191u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (99u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVSXD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (182u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (182u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (182u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (183u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (183u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (201u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: MWAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (144u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (31u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (31u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (12u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (13u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (13u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (13u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (8u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (8u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (9u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (9u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (9u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (10u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (10u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (11u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (11u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (11u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (230u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (231u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (231u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (238u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (239u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (239u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (110u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (111u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (111u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (110u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (111u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (111u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: OUTSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (144u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PAUSE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (143u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (143u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (143u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (88u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (88u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (88u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (31u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (7u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (23u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (161u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (97u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (97u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (184u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPFD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: POPFQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PREFETCHT0) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PREFETCHT1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PREFETCHT2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PREFETCHNTA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (112u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PSHUFW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: PTWRITE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PTWRITE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (106u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (104u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (104u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (14u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (22u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (30u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (6u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (160u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (168u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (96u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSHA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (96u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSHAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSHFD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: PUSHFQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (50u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RDMSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (51u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RDPMC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (49u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RDTSC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (249u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RDTSCP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (195u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (203u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (194u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (202u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (170u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: RSM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (158u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (210u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (211u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (28u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (29u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (29u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (29u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (24u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (25u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (25u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (25u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (26u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (26u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (27u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (27u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (27u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCASB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCASW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SCASD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (175u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SCASQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (151u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (151u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (150u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (150u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (148u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (148u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (159u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (159u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (158u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (158u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (150u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (150u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (146u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (151u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (151u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (147u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (149u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (149u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (158u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (158u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (156u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (157u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SETNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (159u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SETNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (248u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (164u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (164u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (164u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (165u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (172u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (172u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (172u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (173u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (1u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (249u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (253u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (251u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (170u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (170u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STOSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (171u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: STOSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: STR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (44u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (45u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (45u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (45u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (40u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (40u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (41u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (41u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (41u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (42u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (42u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (43u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (43u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (43u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (248u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SWAPGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (5u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SYSCALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (52u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SYSENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (53u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SYSEXIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (53u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SYSEXIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (7u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: SYSRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (7u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: SYSRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (168u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (169u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (246u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (247u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (132u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (132u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (133u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (133u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (133u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (255u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: UD0) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (185u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: UD1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (11u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: UD2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: VERR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: VERW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (155u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: WAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (155u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: FWAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (9u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: WBINVD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (48u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: WRMSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (192u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (193u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (0u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (134u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (135u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (208u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XGETBV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (215u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XLAT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (215u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XLATB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (215u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XLATB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (52u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (53u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (53u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (53u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (128u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (129u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (131u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (48u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (48u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (49u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (49u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (49u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (50u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (50u8 , false , Some ("REX") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (51u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (51u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (51u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XRSTOR64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XRSTORS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XRSTORS64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (174u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVE64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVEC64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (199u8 , false , Some ("REX.W") , None , operands ,) ; match instrs . entry (Mnemonic :: XSAVES64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr :: new (209u8 , false , None , None , operands ,) ; match instrs . entry (Mnemonic :: XSETBV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } instrs } ; }
