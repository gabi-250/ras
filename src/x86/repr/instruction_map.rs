# ! [doc = r" This file was autogenerated by build.rs."]use crate::x86::repr::{InstructionRepr, OperandKind, OperandRepr};
use crate::x86::Mnemonic;
use std::collections::hash_map::Entry;
use std::collections::HashMap;
lazy_static::lazy_static! { pub (crate) static ref INSTR_REPRS : HashMap < Mnemonic , Vec < InstructionRepr >> = { let mut instrs : HashMap < Mnemonic , Vec < InstructionRepr >> = HashMap :: new () ; let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 55u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 10u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 213u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 10u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 212u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 63u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 20u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 21u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 21u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 21u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 16u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 16u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 17u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 17u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 17u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 18u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 18u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 19u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 19u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 19u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 4u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 5u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 5u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 5u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 2u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 2u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 36u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 37u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 37u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 37u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 32u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 32u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 33u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 33u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 33u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 34u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 34u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 35u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 35u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 35u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: AND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 99u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ARPL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 98u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BOUND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 98u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BOUND) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 188u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 188u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 188u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 189u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 189u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 189u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSWAP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BSWAP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 187u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 187u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 187u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 179u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 179u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 179u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 186u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: BTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 232u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 154u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 152u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CBW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 152u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CWDE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 152u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CDQE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 248u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 252u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLFLUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLFLUSHOPT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 250u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 6u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CLTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 245u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 68u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 68u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 68u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 70u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 66u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 71u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 67u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 78u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 76u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 77u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 79u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 65u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 65u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 65u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 75u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 75u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 75u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 73u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 73u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 73u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 69u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 64u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 64u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 64u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 74u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMOVPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 60u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 61u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 61u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 61u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 56u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 56u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 57u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 57u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 57u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 58u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 58u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 59u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 59u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 59u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 166u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 166u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 167u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG8B) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CMPXCHG16B) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 162u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CPUID) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CRC32) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 45u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTPD2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 42u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTPI2PD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 42u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTPI2PS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 45u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTPS2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 44u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTTPD2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 44u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CVTTPS2PI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 153u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CWD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 153u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CDQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 153u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: CQO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 39u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DAA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 47u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 254u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 254u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: DIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 119u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: EMMS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 200u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: F2XM1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 225u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FABS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADDP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FADDP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FBLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FBSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 224u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCHS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 226u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCLEX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 226u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNCLEX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVU) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCMOVNU) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMPP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOMIP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOMI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOMIP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FCOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDECSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 249u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FDIVRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIDIVR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FFREE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FICOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FICOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FICOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FICOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FILD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FINCSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 227u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FINIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 227u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNINIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 223u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISTTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 232u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLD1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 233u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDL2T) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 234u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDL2E) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 235u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDPI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 236u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDLG2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 237u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDLN2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 238u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FLDENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMULP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FMULP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FIMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 243u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FPATAN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 248u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FPREM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 245u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FPREM1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 242u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FPTAN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 252u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FRNDINT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 253u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSCALE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 254u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSIN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 251u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSINCOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 250u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSQRT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 219u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNSTCW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNSTENV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 224u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 224u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FNSTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 233u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 216u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 220u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 225u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FSUBRP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 218u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 222u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FISUBR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 228u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FTST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 225u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 221u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 233u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 233u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FUCOMPP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 229u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXAM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 217u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXCH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXCH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXRSTOR64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXSAVE64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 244u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FXTRACT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FYL2X) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 249u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FYL2XP1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 244u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: HLT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IDIV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 107u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 107u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 107u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 105u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 105u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 105u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IMUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 228u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 229u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 229u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 236u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 237u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 237u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IN) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 254u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 254u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 64u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 64u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 108u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 109u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 109u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 108u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 109u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 109u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 204u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 206u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INTO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 8u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INVD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 15u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: INVLPG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 207u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 207u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IRETD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 207u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: IRETQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JCXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JECXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JRCXZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 130u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 130u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 132u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 132u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 143u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 141u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 140u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 142u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 130u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 133u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 142u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 140u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 141u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 143u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 139u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 137u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 133u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JNZ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 138u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 138u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 139u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JPO) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 136u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 233u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 205u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 234u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: JMP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 159u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LAHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 2u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 2u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 197u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LDS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 197u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LDS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 178u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 178u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 178u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 196u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 196u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 180u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 180u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 180u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LFS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 181u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 181u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 181u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 141u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 141u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 141u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LEAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 232u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LOCK) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 172u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 172u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LODSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LOOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LOOPE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LOOPNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 3u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LSL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: LTR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MASKMOVQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 200u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MONITOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 136u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 136u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 137u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 137u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 137u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 138u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 138u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 139u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 139u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 139u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 140u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 140u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 142u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 142u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 160u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 160u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 162u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 162u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: MemoryOffset , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 163u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 176u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 176u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 198u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 198u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 32u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 32u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 32u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.R") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 34u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 34u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 34u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.R") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 33u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 33u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 35u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 35u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 240u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 241u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 214u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVDQ2Q) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 195u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVNTI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 195u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVNTI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 231u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVNTQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 214u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVQ2DQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 164u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 164u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 190u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 190u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 190u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 191u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 191u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 99u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVSXD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 182u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 182u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 182u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 183u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 183u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MOVZX) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MUL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 201u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: MWAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NEG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 144u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 31u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 31u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: NOT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 12u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 13u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 13u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 13u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 8u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 8u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 9u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 9u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 9u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 10u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 10u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 11u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 11u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 11u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 230u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 231u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 231u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 238u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 239u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 239u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 110u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 111u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 111u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 110u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 111u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 111u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: OUTSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 144u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PAUSE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 143u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 143u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 143u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 88u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 88u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 88u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 31u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 7u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 23u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 161u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 97u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 97u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 184u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPCNT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPFD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: POPFQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PREFETCHT0) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PREFETCHT1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PREFETCHT2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PREFETCHNTA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 112u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PSHUFW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PTWRITE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PTWRITE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 106u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 104u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 104u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 14u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 22u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 30u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 6u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 160u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 168u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSH) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 96u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSHA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 96u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSHAD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSHFD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: PUSHFQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RCR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: ROR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 50u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RDMSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 51u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RDPMC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 49u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RDTSC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 249u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RDTSCP) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 195u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 203u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 194u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 202u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 170u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: RSM) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 158u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAHF) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SAR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 210u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: One , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 211u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 28u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 29u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 29u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 29u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 24u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 25u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 25u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 25u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 26u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 26u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 27u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 27u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 27u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SBB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCAS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCASB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCASW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCASD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 175u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SCASQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 151u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 151u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 150u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 150u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 148u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 148u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 159u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 159u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 158u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 158u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 150u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 150u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNA) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 146u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNAE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 151u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 151u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNBE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 147u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 149u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 149u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 158u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 158u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 156u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNGE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 157u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 159u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SETNLE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 248u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SFENCE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SGDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 164u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 164u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 164u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 165u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHLD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 172u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 172u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 172u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Cl , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 173u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SHRD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SIDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SLDT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 1u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SMSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 249u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 253u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 251u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STI) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 170u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 170u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOSB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOSW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOSD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 171u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STOSQ) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: STR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 44u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 45u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 45u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 45u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 40u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 40u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 41u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 41u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 41u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 42u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 42u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 43u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 43u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 43u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SUB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 248u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SWAPGS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 5u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSCALL) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 52u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSENTER) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 53u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSEXIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 53u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSEXIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 7u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 7u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: SYSRET) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 168u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 169u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 246u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 247u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 132u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 132u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 133u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 133u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 133u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: TEST) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 255u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: UD0) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 185u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: UD1) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 11u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: UD2) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: VERR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: VERW) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 155u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: WAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 155u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: FWAIT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 9u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: WBINVD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 48u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: WRMSR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 192u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 193u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XADD) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: OpcodeRd , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 0u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 134u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 135u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XCHG) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 208u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XGETBV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 215u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XLAT) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 215u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XLATB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 215u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XLATB) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 52u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 53u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 53u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: Al , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 53u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 128u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 129u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: Imm , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 131u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 48u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 48u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 49u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 49u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 49u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 50u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 50u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 8usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 51u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 32usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 32usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 51u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmReg , 64usize)) { operands . push (op) ; } if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 64usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 51u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XRSTOR) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XRSTOR64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XRSTORS) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XRSTORS64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVE) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = Some (OperandRepr :: new (OperandKind :: ModRmRegMem , 8usize)) { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 174u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVE64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVEC) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVEC64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVES) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 199u8 , sib : false , rex_prefix : Some (std :: str :: FromStr :: from_str ("REX.W") . unwrap ()) , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSAVES64) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } let mut operands = Vec :: with_capacity (4) ; if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } if let Some (op) = None { operands . push (op) ; } let instr = InstructionRepr { opcode : 209u8 , sib : false , rex_prefix : None , opcode_extension : None , operands , } ; match instrs . entry (Mnemonic :: XSETBV) { Entry :: Occupied (mut e) => e . get_mut () . push (instr) , Entry :: Vacant (e) => { e . insert (vec ! [instr]) ; } , } instrs } ; }
