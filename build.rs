use lazy_static::lazy_static;
use proc_macro2::TokenStream;
use quote::quote;
use regex::Regex;
use std::collections::HashSet;
use std::fs::File;
use std::io::Write;
use std::path::Path;

const INSTR_CSV: &str = "x86-csv/x86.csv";

lazy_static! {
    static ref MODRM_REG_RE: Regex = Regex::new("ModRM:reg").unwrap();
    static ref MODRM_RM_RE: Regex = Regex::new("ModRM:r/?m").unwrap();
    static ref ALL_ACC_RE: Regex = Regex::new("AL/AX/EAX/RAX").unwrap();
    static ref ACC_OVER_16_RE: Regex = Regex::new("AX/EAX/RAX").unwrap();
    static ref IMM_RE: Regex = Regex::new("imm8/16/32").unwrap();
    static ref IMM8_RE: Regex = Regex::new("imm8").unwrap();
    static ref IW_RE: Regex = Regex::new("iw").unwrap();
    static ref MOFFS_RE: Regex = Regex::new("Moffs").unwrap();
    static ref OPCODE_RD_RE: Regex = Regex::new("opcode \\+ ?rd").unwrap();
}

#[allow(unused)]
#[repr(u8)]
enum CsvHeader {
    Instruction,
    Opcode,
    Valid64,
    Valid32,
    Valid16,
    FeatureFlags,
    Operand1,
    Operand2,
    Operand3,
    Operand4,
    TupleType,
    Description,
}

fn main() {
    generate_instruction_repr();
}

fn generate_instruction_repr() {
    let mut rdr = csv::Reader::from_reader(
        File::open(Path::new(env!("CARGO_MANIFEST_DIR")).join(INSTR_CSV)).unwrap(),
    );

    let mut mnemonics = HashSet::new();
    let mut build_instrs = TokenStream::new();

    for rec in rdr.records() {
        let rec = rec.unwrap();

        // XXX: forget about special instructions for now
        if matches!(rec.get(CsvHeader::FeatureFlags as usize), Some(flags) if flags != "") {
            continue;
        }

        let (mnemonic, size1, size2, size3, size4) =
            parse_mnemonic(rec.get(CsvHeader::Instruction as usize).unwrap());
        let (opcode, rex_prefix) = parse_instr(rec.get(CsvHeader::Opcode as usize).unwrap());

        let operand_encoding1 =
            build_operand_enc(rec.get(CsvHeader::Operand1 as usize).unwrap(), size1);
        let operand_encoding2 =
            build_operand_enc(rec.get(CsvHeader::Operand2 as usize).unwrap(), size2);
        let operand_encoding3 =
            build_operand_enc(rec.get(CsvHeader::Operand3 as usize).unwrap(), size3);
        let operand_encoding4 =
            build_operand_enc(rec.get(CsvHeader::Operand4 as usize).unwrap(), size4);

        {
            let mnemonic = mnemonic.parse::<TokenStream>().unwrap();
            let rex_prefix_tok = match rex_prefix {
                None => quote! { None },
                Some(s) => quote! { Some(std::str::FromStr::from_str(#s).unwrap()) },
            };

            build_instrs.extend(quote! {
                let mut operand_encodings = Vec::with_capacity(4);

                if let Some(op) = #operand_encoding1 {
                    operand_encodings.push(op);
                }

                if let Some(op) = #operand_encoding2 {
                    operand_encodings.push(op);
                }

                if let Some(op) = #operand_encoding3 {
                    operand_encodings.push(op);
                }

                if let Some(op) = #operand_encoding4 {
                    operand_encodings.push(op);
                }

                let instr = InstructionRepr {
                    opcode: #opcode,
                    sib: false,
                    rex_prefix: #rex_prefix_tok,
                    opcode_extension: None,
                    operand_encodings,
                };

                match instrs.entry(Mnemonic::#mnemonic) {
                    Entry::Occupied(mut e) => e.get_mut().push(instr),
                    Entry::Vacant(e) => { e.insert(vec![instr]); },
                }
            });
        }

        mnemonics.insert(mnemonic);
    }

    let mut variants = TokenStream::new();
    for mnemonic in mnemonics {
        let mnemonic = mnemonic.parse::<TokenStream>().unwrap();
        variants.extend(quote! {
            #mnemonic,
        });
    }

    let content = quote! {
        //! This file was autogenerated by build.rs.
        use std::hash::Hash;

        #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
        pub enum Mnemonic {
            #variants
        }
    };

    let path = format!("{}/src/x86/mnemonic.rs", env!["CARGO_MANIFEST_DIR"]);
    let mut mnemonic_file = File::create(path).unwrap();
    write!(mnemonic_file, "{}", content).unwrap();

    let content = quote! {
        //! This file was autogenerated by build.rs.
        use crate::x86::Mnemonic;
        use crate::x86::instruction_encoding::{InstructionRepr, OperandEncoding, OperandKind};
        use std::collections::HashMap;
        use std::collections::hash_map::Entry;

        lazy_static::lazy_static! {
            pub(crate) static ref INSTR_REPRS: HashMap<Mnemonic, Vec<InstructionRepr>> = {
                let mut instrs: HashMap<Mnemonic, Vec<InstructionRepr>> = HashMap::new();
                #build_instrs
                instrs
            };
        }
    };

    let path = format!("{}/src/x86/instruction_repr.rs", env!["CARGO_MANIFEST_DIR"]);
    let mut mnemonic_file = File::create(path).unwrap();
    write!(mnemonic_file, "{}", content).unwrap();
}

fn parse_mnemonic(mnemonic: &str) -> (String, usize, usize, usize, usize) {
    let mnemonic_idx = mnemonic.find(" ").unwrap_or(mnemonic.len());
    let (mnemonic, operands) = mnemonic.split_at(mnemonic_idx);

    let mut operands = operands.split(",").filter_map(|s| {
        let s = s.trim();

        if s.is_empty() {
            None
        } else {
            Some(s)
        }
    });

    let operand1 = operands.next().map(operand_size).unwrap_or_default();
    let operand2 = operands.next().map(operand_size).unwrap_or_default();
    let operand3 = operands.next().map(operand_size).unwrap_or_default();
    let operand4 = operands.next().map(operand_size).unwrap_or_default();

    // There can't be more than 4 operands
    assert!(operands.next().is_none());

    (mnemonic.to_string(), operand1, operand2, operand3, operand4)
}

fn operand_size(op: &str) -> usize {
    // XXX implement me
    if dbg!(op).ends_with("64") || op == "RAX" {
        return 64;
    } else if op.ends_with("32") || op == "EAX" {
        return 32;
    }

    8
}

fn parse_instr(instr: &str) -> (u8, Option<&str>) {
    let mut instr = instr.split(" ");
    let mut opcode = 0;
    let mut rex_prefix = None;

    loop {
        match instr.next() {
            Some(op) if u8::from_str_radix(op, 16).is_ok() => {
                opcode = u8::from_str_radix(op, 16).unwrap();

                continue;
            }
            Some(prefix) if prefix.starts_with("REX") => {
                rex_prefix = Some(prefix);

                continue;
            }
            Some("+") => continue,
            None => break,
            _ => continue, // XXX
        }
    }

    (opcode, rex_prefix)
}

fn build_operand_enc(operand: &str, size: usize) -> TokenStream {
    if MODRM_REG_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::ModRmReg, #size)) };
    } else if MODRM_RM_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::ModRmRegMem, #size)) };
    } else if ALL_ACC_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::Al, #size)) };
    } else if ACC_OVER_16_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::Al, #size)) };
    } else if IMM_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::Imm, #size)) };
    } else if IMM8_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::Imm, #size)) };
    } else if IW_RE.is_match(operand) || operand == "imm16" {
        return quote! { Some(OperandEncoding::new(OperandKind::Imm, #size)) };
    } else if OPCODE_RD_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::OpcodeRd, #size)) };
    } else if MOFFS_RE.is_match(operand) {
        return quote! { Some(OperandEncoding::new(OperandKind::MemoryOffset, #size)) };
    } else if operand == "1" {
        return quote! { Some(OperandEncoding::new(OperandKind::One, #size)) }; // XXX
    } else if operand == "CL" {
        return quote! { Some(OperandEncoding::new(OperandKind::Cl, #size)) }; // XXX
    } else if operand == "NA" || operand == "" {
        return quote! { None };
    } else {
        unimplemented!("operand mode for {}", operand);
    }
}
