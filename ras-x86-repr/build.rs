use proc_macro2::TokenStream;
use quote::quote;
use ras_x86_csv::*;
use std::collections::HashSet;
use std::fs::{self, File};
use std::path::Path;

const INSTR_CSV: &str = "../ras-x86-csv/x86-csv/x86.csv";

fn main() {
    generate_instruction_repr();
}

fn generate_instruction_repr() {
    let mut rdr = csv::Reader::from_reader(
        File::open(Path::new(env!("CARGO_MANIFEST_DIR")).join(INSTR_CSV)).unwrap(),
    );

    let mut mnemonics = HashSet::new();

    for rec in rdr.records() {
        let rec = rec.unwrap();

        // XXX: forget about special instructions for now
        if matches!(rec.get(CsvHeader::FeatureFlags as usize), Some(flags) if !flags.is_empty()) {
            continue;
        }

        let (mnemonic, ..) = parse_mnemonic(rec.get(CsvHeader::Instruction as usize).unwrap());

        mnemonics.insert(mnemonic);
    }

    let mnemonics = mnemonics.into_iter().collect::<Vec<_>>();
    let mut variants = vec![]; //TokenStream::new();

    for mnemonic in mnemonics.iter() {
        let mnemonic = mnemonic.parse::<TokenStream>().unwrap();
        variants.push(quote! { #mnemonic });
    }

    let content = quote! {
        //! This file was autogenerated by build.rs.
        use std::hash::Hash;
        use serde::{Serialize, Deserialize};
        use std::str::FromStr;

        #[derive(Copy, Clone, Eq, PartialEq, Hash, Serialize, Deserialize)]
        pub enum Mnemonic {
            #(#variants),*
        }

        impl FromStr for Mnemonic {
            type Err = String;

            fn from_str(s: &str) -> Result<Self, Self::Err> {
                match s {
                    #( #mnemonics => Ok(Mnemonic::#variants), )*
                    s => Err(format!("unknown mnemonic: {}", s))
                }
            }
        }
    };

    let mnemonic_file = Path::new(env!("CARGO_MANIFEST_DIR")).join("src/mnemonic.rs");
    fs::write(mnemonic_file, content.to_string()).unwrap();
}
